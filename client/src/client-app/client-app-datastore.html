<link rel="import" href="../libs/immutable-js.html">
<link rel="import" href="../libs/redux-js.html">

<script>
  const Schema = (function () {
    return {
      Wind:
        Immutable.Record({
          strength: 1.0,
          direction: 0
        }, 'Wind'),
      Boat:
        Immutable.Record({
          position: undefined,
          direction: undefined,
          windDirection: undefined,
          natSpeed: 1,
          originalPort: undefined,
          targetPort: undefined
        }, 'Boat'),
      Port:
        Immutable.Record({
          name: undefined,
          position: undefined
        }, 'Port'),
      WeatherStation:
        Immutable.Record({
          name: undefined,
          position: undefined,
          strength: 1.0,
          direction: 0
        }, 'WeatherStation'),
      MeshCoord:
        Immutable.Record({
          row: undefined,
          col: undefined
        }, 'MeshCoord'),
      Mesh:
        Immutable.Record({
          width: undefined,
          height: undefined,
          tiles: undefined
        })
    }
  })();

  var Datastore = (function () {
    // Sidenote:
    //
    // The above anonymous function declaration comes from a classical
    // Javascript idiom, to create a local scope, to avoid variables,
    // constants and function declarations to inadvertendly pollute
    // the global scope:
    //
    // (function () { some(); code(); then(); return { a value }})()
    //
    // Within the first parenthesis, we declare and return an anonymous function;
    // with the two last parenthesis, we immediately invoke that new function,
    // effectively returning the value; variables that would be created
    // within the scope of the anonymous function would be kept local.

    const actionHandler = function (state = Immutable.Map(), action) {
      switch (action.type) {
        case 'SHUFFLE_BOAT_DIRECTIONS':
          return state.update( 'boats', (boats) =>
            boats.map((boat) =>
              boat.update( 'direction', function (direction) { 
                return direction = Math.floor(Math.random() * 360);
              }
                
                )))
        default:
          return state
      }
    }

    const initialState = Immutable.Map({
      boats: Immutable.Map({
        'BOAT1': new Schema.Boat({
          position: new Schema.MeshCoord({ row: 19, col: 0 }),
          direction: 0,
          windDirection: 0,
          originalPort: 'GVA',
          targetPort: 'LSNE' }),
        'BOAT2': new Schema.Boat({
          position: new Schema.MeshCoord({ row: 10, col: 8 }),
          direction: 0,
          windDirection: 60,
          originalPort: 'GVA',
          targetPort: 'LSNE' }),
        'BOAT3': new Schema.Boat({
          position: new Schema.MeshCoord({ row: 12, col: 3 }),
          direction: 0,
          windDirection: 90,
          originalPort: 'GVA',
          targetPort: 'LSNE' }),
        'BOAT4': new Schema.Boat({
          position: new Schema.MeshCoord({ row: 9, col: 12 }),
          direction: 0,
          windDirection: 180,
          originalPort: 'GVA',
          targetPort: 'LSNE' })
      }),
      ports: Immutable.Map({
        'LSNE': new Schema.Port({
          name: 'Lausanne',
          position: new Schema.MeshCoord({ row: 0, col: 18 })
        }),
        'GVA': new Schema.Port({
          name: 'Geneva',
          position: new Schema.MeshCoord({ row: 21, col: 0 })
        }),
        'NYN': new Schema.Port({
          name: 'Nyon',
          position: new Schema.MeshCoord({ row: 9, col: 4 })
        }),
        'TLB': new Schema.Port({
          name: 'Thonons-Les-Bains',
          position: new Schema.MeshCoord({ row: 9, col: 13 })
        }),
        'MTX': new Schema.Port({
          name: 'Montreux',
          position: new Schema.MeshCoord({ row: 6, col: 31 })
        })
      }),
      weatherStations: Immutable.Map({
        'WeatherStation1': new Schema.WeatherStation({
          name: 'WeatherStation1',
          position: new Schema.MeshCoord({ row: 2, col: 9 })
        })
      }),
      lakeMesh: new Schema.Mesh({
        width: 32,
        height: 22,
        tiles: [
          // rows 0-9
          // 0                            10                            20                            30  
          [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 ]
        , [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 ]
        , [ 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 ]
        , [ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
        , [ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
        , [ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0 ]
        , [ 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
          // rows 10-19
          // 0                            10                            20                            30
        , [ 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
          // rows 20-21
          // 0                            10                            20                            30
        , [ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        , [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        ]
      })
    });

    return Redux.createStore( actionHandler, initialState);
  })();
</script>