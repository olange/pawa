<link rel="import" href="client-app-datastore.html">

<script>
  const Renderer = (function () {
    return {
      geometricReference( position) {
        var run = true;

        //Currently since Camera is set on (0,0), the top right starts at (-300,-200)
        const minX = geometricMinX();
        const minY = geometricMinY();
        const scale = geometricScaler();

        var posX = position.x;
        var posY = position.y;

        var r = 0;
        var c = 0;
        while( posX > minX) {
          posX -= scale;
          r++;
        }
        while( posY > minY) {
          posY -= scale;
          c++;
        }

        //returns a record with the row and collumn its in
        return new Schema.GeoLocation({
          row: r,
          column: c
        });
      }, // geometricReference

      convertMatrixToCoordinates( geoloc) {
        const realX = (0.5 + geoloc.column) * Renderer.geometricScaler() + Renderer.geometricMinX();
        const realY = (0.5 + geoloc.row) * Renderer.geometricScaler() + Renderer.geometricMinY();
        return new Schema.Position({ x: realX, y: realY });
      },

      //Use to scale geometric back to x and y
      //Currently 16 by 12 squares, each square is 50 pixels
      geometricScaler() {
        return 64;
      },

      geometricMinX() {
        return -300;
      },

      geometricMinY() {
        return -200;
      },
      //Create function called isLand?

      //The parameters create new variables right?
      // Answer: depends on whether the argument is of a primitive type (Int, Float, …)
      // or an object. If it is primitive, yes. Otherwise no, you get new references…
      // to the object; and if you mutate a property of the object, then you mutate
      // the original object! Best practice: never update arguments; or create duplicates
      // of objects, when the arguments are objects and you would need to return a
      // updated version of the orignal object: `Object.assign( {}, arg, { … });`
      drawBoatSprite( scene, pos, windDirection, rotBoat) {
        var boatDirQuadrant = 0;
        var sailTypeHolder = [1, 2, 1, 0];  //Look at paper I made showing how wind interacts with different sail directions
        var calcSailType = 0;
        var sailType = 0;

        if (rotBoat >= 315 || rotBoat < 45) {
          //facing up
          boatDirQuadrant = 0;
        } else if (rotBoat >=  45 && rotBoat < 135) {
          //facing right
          boatDirQuadrant = 1;
        } else if (rotBoat >= 135 &&  rotBoat < 225) {
          //facing down
          boatDirQuadrant = 2;
        } else if (rotBoat >=  225 && rotBoat < 315) {
          //facing left
          boatDirQuadrant = 3;
        }

        if (windDirection >= 315 || windDirection < 45) {
          //If wind Direction is either north
          calcSailType = boatDirQuadrant;
        } else if (windDirection >=  45 && windDirection < 135) {
          //If the wind direction is East
          calcSailType = boatDirQuadrant + 1;
        } else if (windDirection >= 135 && windDirection < 225) {
          //South
          calcSailType = boatDirQuadrant + 2;
        } else if (windDirection >=  225 && windDirection < 315) {
          //If the wind direction is west
          calcSailType = boatDirQuadrant + 3;
        }

        if (calcSailType > 2) { 
          calcSailType = calcSailType - 2;
        }
        console.log( sailTypeHolder[ calcSailType]);

        const boatS = scene.add.sprite( pos.x, pos.y, 'boat', sailTypeHolder[ calcSailType]); //Not sure this is correct
        boatS.setAngle( rotBoat);
      }, // drawBoatSprite

      //If we are sending the wind object itself, change so it accepts that wind, and then changes the sprite it is associated with
      //Send wind coordiantes, then get the wind drawn in the geocordinates by a draw windsprite function

      drawWindSprite( scene, geoPos, windStrength, rotWind) {
        var windSpriteType = 0;
        if (windStrength == 1) {
          windSpriteType = 1;
        } else if (windStrength == 2) {
          windSpriteType = 2;
        } else if (windStrength == 3) {
          windSpriteType = 3;
        }

        //This only works assuming position is a matrix like geolocation, otherwise add geolocation value
        //(phaserGame.windSpriteWidth / 2)
        //  + (phaserGame.windSpriteHeight / 2)
        console.dir( geoPos);
        const windSpriteDraw = Renderer.convertMatrixToCoordinates( geoPos);
        console.dir( windSpriteDraw);

        //Does this really get a point? No it gets the top corner of a point

        //var test = phaserGame.windSpriteWidth;

        const wind = scene.add.sprite( windSpriteDraw.x, windSpriteDraw.y, 'wind', windSpriteType); //Not sure this is correct

        //rotWind
        wind.setAngle( rotWind); //Not sure if this works or not
      } // drawWindSprite      
    };
  })();
</script>      